<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<link href="style.css" rel="stylesheet" type="text/css"/>
<title>Thrift module: Client</title></head><body>
<h1>Thrift module: Client</h1>
<table><tr><th>Module</th><th>Services</th><th>Data types</th><th>Constants</th></tr>
<tr>
<td>Client</td><td><a href="Client.html#Svc_ClientService">ClientService</a><br/>
<ul>
<li><a href="Client.html#Fn_ClientService_alter_table">alter_table</a></li>
<li><a href="Client.html#Fn_ClientService_cancel_future">cancel_future</a></li>
<li><a href="Client.html#Fn_ClientService_close_future">close_future</a></li>
<li><a href="Client.html#Fn_ClientService_close_mutator">close_mutator</a></li>
<li><a href="Client.html#Fn_ClientService_close_mutator_async">close_mutator_async</a></li>
<li><a href="Client.html#Fn_ClientService_close_namespace">close_namespace</a></li>
<li><a href="Client.html#Fn_ClientService_close_scanner">close_scanner</a></li>
<li><a href="Client.html#Fn_ClientService_close_scanner_async">close_scanner_async</a></li>
<li><a href="Client.html#Fn_ClientService_create_namespace">create_namespace</a></li>
<li><a href="Client.html#Fn_ClientService_create_table">create_table</a></li>
<li><a href="Client.html#Fn_ClientService_drop_namespace">drop_namespace</a></li>
<li><a href="Client.html#Fn_ClientService_drop_table">drop_table</a></li>
<li><a href="Client.html#Fn_ClientService_exists_namespace">exists_namespace</a></li>
<li><a href="Client.html#Fn_ClientService_exists_table">exists_table</a></li>
<li><a href="Client.html#Fn_ClientService_flush_mutator">flush_mutator</a></li>
<li><a href="Client.html#Fn_ClientService_flush_mutator_async">flush_mutator_async</a></li>
<li><a href="Client.html#Fn_ClientService_future_has_outstanding">future_has_outstanding</a></li>
<li><a href="Client.html#Fn_ClientService_future_is_cancelled">future_is_cancelled</a></li>
<li><a href="Client.html#Fn_ClientService_future_is_empty">future_is_empty</a></li>
<li><a href="Client.html#Fn_ClientService_future_is_full">future_is_full</a></li>
<li><a href="Client.html#Fn_ClientService_get_cell">get_cell</a></li>
<li><a href="Client.html#Fn_ClientService_get_cells">get_cells</a></li>
<li><a href="Client.html#Fn_ClientService_get_cells_as_arrays">get_cells_as_arrays</a></li>
<li><a href="Client.html#Fn_ClientService_get_cells_serialized">get_cells_serialized</a></li>
<li><a href="Client.html#Fn_ClientService_get_future_result">get_future_result</a></li>
<li><a href="Client.html#Fn_ClientService_get_future_result_as_arrays">get_future_result_as_arrays</a></li>
<li><a href="Client.html#Fn_ClientService_get_future_result_serialized">get_future_result_serialized</a></li>
<li><a href="Client.html#Fn_ClientService_get_listing">get_listing</a></li>
<li><a href="Client.html#Fn_ClientService_get_row">get_row</a></li>
<li><a href="Client.html#Fn_ClientService_get_row_as_arrays">get_row_as_arrays</a></li>
<li><a href="Client.html#Fn_ClientService_get_row_serialized">get_row_serialized</a></li>
<li><a href="Client.html#Fn_ClientService_get_schema">get_schema</a></li>
<li><a href="Client.html#Fn_ClientService_get_schema_str">get_schema_str</a></li>
<li><a href="Client.html#Fn_ClientService_get_schema_str_with_ids">get_schema_str_with_ids</a></li>
<li><a href="Client.html#Fn_ClientService_get_table_id">get_table_id</a></li>
<li><a href="Client.html#Fn_ClientService_get_table_splits">get_table_splits</a></li>
<li><a href="Client.html#Fn_ClientService_get_tables">get_tables</a></li>
<li><a href="Client.html#Fn_ClientService_next_cells">next_cells</a></li>
<li><a href="Client.html#Fn_ClientService_next_cells_as_arrays">next_cells_as_arrays</a></li>
<li><a href="Client.html#Fn_ClientService_next_cells_serialized">next_cells_serialized</a></li>
<li><a href="Client.html#Fn_ClientService_next_row">next_row</a></li>
<li><a href="Client.html#Fn_ClientService_next_row_as_arrays">next_row_as_arrays</a></li>
<li><a href="Client.html#Fn_ClientService_next_row_serialized">next_row_serialized</a></li>
<li><a href="Client.html#Fn_ClientService_offer_cell">offer_cell</a></li>
<li><a href="Client.html#Fn_ClientService_offer_cell_as_array">offer_cell_as_array</a></li>
<li><a href="Client.html#Fn_ClientService_offer_cells">offer_cells</a></li>
<li><a href="Client.html#Fn_ClientService_offer_cells_as_arrays">offer_cells_as_arrays</a></li>
<li><a href="Client.html#Fn_ClientService_open_future">open_future</a></li>
<li><a href="Client.html#Fn_ClientService_open_mutator">open_mutator</a></li>
<li><a href="Client.html#Fn_ClientService_open_mutator_async">open_mutator_async</a></li>
<li><a href="Client.html#Fn_ClientService_open_namespace">open_namespace</a></li>
<li><a href="Client.html#Fn_ClientService_open_scanner">open_scanner</a></li>
<li><a href="Client.html#Fn_ClientService_open_scanner_async">open_scanner_async</a></li>
<li><a href="Client.html#Fn_ClientService_refresh_shared_mutator">refresh_shared_mutator</a></li>
<li><a href="Client.html#Fn_ClientService_rename_table">rename_table</a></li>
<li><a href="Client.html#Fn_ClientService_set_cell">set_cell</a></li>
<li><a href="Client.html#Fn_ClientService_set_cell_as_array">set_cell_as_array</a></li>
<li><a href="Client.html#Fn_ClientService_set_cell_as_array_async">set_cell_as_array_async</a></li>
<li><a href="Client.html#Fn_ClientService_set_cell_async">set_cell_async</a></li>
<li><a href="Client.html#Fn_ClientService_set_cells">set_cells</a></li>
<li><a href="Client.html#Fn_ClientService_set_cells_as_arrays">set_cells_as_arrays</a></li>
<li><a href="Client.html#Fn_ClientService_set_cells_as_arrays_async">set_cells_as_arrays_async</a></li>
<li><a href="Client.html#Fn_ClientService_set_cells_async">set_cells_async</a></li>
<li><a href="Client.html#Fn_ClientService_set_cells_serialized">set_cells_serialized</a></li>
<li><a href="Client.html#Fn_ClientService_set_cells_serialized_async">set_cells_serialized_async</a></li>
</ul>
</td>
<td><a href="Client.html#Struct_AccessGroup">AccessGroup</a><br/>
<a href="Client.html#Struct_Cell">Cell</a><br/>
<a href="Client.html#Typedef_CellAsArray">CellAsArray</a><br/>
<a href="Client.html#Struct_CellInterval">CellInterval</a><br/>
<a href="Client.html#Typedef_CellsSerialized">CellsSerialized</a><br/>
<a href="Client.html#Struct_ClientException">ClientException</a><br/>
<a href="Client.html#Struct_ColumnFamily">ColumnFamily</a><br/>
<a href="Client.html#Typedef_Future">Future</a><br/>
<a href="Client.html#Struct_Key">Key</a><br/>
<a href="Client.html#Enum_KeyFlag">KeyFlag</a><br/>
<a href="Client.html#Struct_MutateSpec">MutateSpec</a><br/>
<a href="Client.html#Typedef_Mutator">Mutator</a><br/>
<a href="Client.html#Typedef_MutatorAsync">MutatorAsync</a><br/>
<a href="Client.html#Enum_MutatorFlag">MutatorFlag</a><br/>
<a href="Client.html#Typedef_Namespace">Namespace</a><br/>
<a href="Client.html#Struct_NamespaceListing">NamespaceListing</a><br/>
<a href="Client.html#Struct_Result">Result</a><br/>
<a href="Client.html#Struct_ResultAsArrays">ResultAsArrays</a><br/>
<a href="Client.html#Struct_ResultSerialized">ResultSerialized</a><br/>
<a href="Client.html#Struct_RowInterval">RowInterval</a><br/>
<a href="Client.html#Struct_ScanSpec">ScanSpec</a><br/>
<a href="Client.html#Typedef_Scanner">Scanner</a><br/>
<a href="Client.html#Typedef_ScannerAsync">ScannerAsync</a><br/>
<a href="Client.html#Struct_Schema">Schema</a><br/>
<a href="Client.html#Struct_TableSplit">TableSplit</a><br/>
<a href="Client.html#Typedef_Value">Value</a><br/>
</td>
<td><code></code></td>
</tr></table>
<hr/><h2 id="Enumerations">Enumerations</h2>
<div class="definition"><h3 id="Enum_KeyFlag">Enumeration: KeyFlag</h3>
State flags for a key
<p/>
Note for maintainers: the definition must be sync'ed with FLAG_* constants
in src/cc/Hypertable/Lib/Key.h
<p/>
DELETE_ROW: row is pending delete
<p/>
DELETE_CF: column family is pending delete
<p/>
DELETE_CELL: key is pending delete
<p/>
DELETE_CELL_VERSION: delete specific timestamped version of key
<p/>
INSERT: key is an insert/update (default state)
<br/><br/><table>
<tr><td><code>DELETE_ROW</code></td><td><code>0</code></td></tr>
<tr><td><code>DELETE_CF</code></td><td><code>1</code></td></tr>
<tr><td><code>DELETE_CELL</code></td><td><code>2</code></td></tr>
<tr><td><code>DELETE_CELL_VERSION</code></td><td><code>3</code></td></tr>
<tr><td><code>INSERT</code></td><td><code>255</code></td></tr>
</table></div>
<div class="definition"><h3 id="Enum_MutatorFlag">Enumeration: MutatorFlag</h3>
Mutator creation flags
<p/>
NO_LOG_SYNC: Do not sync the commit log
IGNORE_UNKNOWN_CFS: Don't throw exception if mutator writes to unknown column family
<br/><br/><table>
<tr><td><code>NO_LOG_SYNC</code></td><td><code>1</code></td></tr>
<tr><td><code>IGNORE_UNKNOWN_CFS</code></td><td><code>2</code></td></tr>
</table></div>
<hr/><h2 id="Typedefs">Type declarations</h2>
<div class="definition"><h3 id="Typedef_Future">Typedef: Future</h3>
<p><strong>Base type:</strong>&nbsp;<code>i64</code></p>
Opaque ID for a Future object
<p/>
<br/></div>
<div class="definition"><h3 id="Typedef_Namespace">Typedef: Namespace</h3>
<p><strong>Base type:</strong>&nbsp;<code>i64</code></p>
Opaque ID for a Namespace
<p/>
<br/></div>
<div class="definition"><h3 id="Typedef_Scanner">Typedef: Scanner</h3>
<p><strong>Base type:</strong>&nbsp;<code>i64</code></p>
Opaque ID for a table scanner
<p/>
A scanner is recommended for returning large amount of data, say a full
table dump.
<br/></div>
<div class="definition"><h3 id="Typedef_ScannerAsync">Typedef: ScannerAsync</h3>
<p><strong>Base type:</strong>&nbsp;<code>i64</code></p>
Opaque ID for a asynchronous table scanner
<p/>
A scanner is recommended for returning large amount of data, say a full
table dump.
<br/></div>
<div class="definition"><h3 id="Typedef_Mutator">Typedef: Mutator</h3>
<p><strong>Base type:</strong>&nbsp;<code>i64</code></p>
Opaque ID for a table mutator
<p/>
A mutator is recommended for injecting large amount of data (across
many calls to mutator methods)
<br/></div>
<div class="definition"><h3 id="Typedef_MutatorAsync">Typedef: MutatorAsync</h3>
<p><strong>Base type:</strong>&nbsp;<code>i64</code></p>
Opaque ID for a asynchronous table mutator
<p/>
A mutator is recommended for injecting large amount of data (across
many calls to mutator methods)
<br/></div>
<div class="definition"><h3 id="Typedef_Value">Typedef: Value</h3>
<p><strong>Base type:</strong>&nbsp;<code>string</code></p>
Value for table cell
<p/>
Use binary instead of string to generate efficient type for Java.
<br/></div>
<div class="definition"><h3 id="Typedef_CellAsArray">Typedef: CellAsArray</h3>
<p><strong>Base type:</strong>&nbsp;<code>list&lt;<code>string</code>&gt;</code></p>
Alternative Cell interface for languages (e.g., Ruby) where user defined
objects are much more expensive to create than builtin primitives. The order
of members is the same as that in the <a href="#Struct_Cell">Cell</a> object
definition.
<p/>
The returned cells (as arrays) contain Cell as array:
["row_key", "column_family", "column_qualifier", "value", "timestamp"]
<p/>
Note, revision and cell flag are not returned for the array interface.
<br/></div>
<div class="definition"><h3 id="Typedef_CellsSerialized">Typedef: CellsSerialized</h3>
<p><strong>Base type:</strong>&nbsp;<code>string</code></p>
Binary buffer holding serialized sequence of cells
<br/></div>
<hr/><h2 id="Structs">Data structures</h2>
<div class="definition"><h3 id="Struct_RowInterval">Struct: RowInterval</h3>
<table><tr><th>Key</th><th>Field</th><th>Type</th><th>Description</th><th>Requiredness</th><th>Default value</th></tr>
<tr><td>1</td><td>start_row</td><td><code>string</code></td><td></td><td>optional</td><td></td></tr>
<tr><td>2</td><td>start_inclusive</td><td><code>bool</code></td><td></td><td>optional</td><td>1</td></tr>
<tr><td>3</td><td>end_row</td><td><code>string</code></td><td></td><td>optional</td><td></td></tr>
<tr><td>4</td><td>end_inclusive</td><td><code>bool</code></td><td></td><td>optional</td><td>1</td></tr>
</table><br/>Specifies a range of rows
<p/>
<dl>
  <dt>start_row</dt>
  <dd>The row to start scan with. Must not contain nulls (0x00)</dd>
<p/>
  <dt>start_inclusive</dt>
  <dd>Whether the start row is included in the result (default: true)</dd>
<p/>
  <dt>end_row</dt>
  <dd>The row to end scan with. Must not contain nulls</dd>
<p/>
  <dt>end_inclusive</dt>
  <dd>Whether the end row is included in the result (default: true)</dd>
</dl>
<br/></div><div class="definition"><h3 id="Struct_CellInterval">Struct: CellInterval</h3>
<table><tr><th>Key</th><th>Field</th><th>Type</th><th>Description</th><th>Requiredness</th><th>Default value</th></tr>
<tr><td>1</td><td>start_row</td><td><code>string</code></td><td></td><td>optional</td><td></td></tr>
<tr><td>2</td><td>start_column</td><td><code>string</code></td><td></td><td>optional</td><td></td></tr>
<tr><td>3</td><td>start_inclusive</td><td><code>bool</code></td><td></td><td>optional</td><td>1</td></tr>
<tr><td>4</td><td>end_row</td><td><code>string</code></td><td></td><td>optional</td><td></td></tr>
<tr><td>5</td><td>end_column</td><td><code>string</code></td><td></td><td>optional</td><td></td></tr>
<tr><td>6</td><td>end_inclusive</td><td><code>bool</code></td><td></td><td>optional</td><td>1</td></tr>
</table><br/>Specifies a range of cells
<p/>
<dl>
  <dt>start_row</dt>
  <dd>The row to start scan with. Must not contain nulls (0x00)</dd>
<p/>
  <dt>start_column</dt>
  <dd>The column (prefix of column_family:column_qualifier) of the
  start row for the scan</dd>
<p/>
  <dt>start_inclusive</dt>
  <dd>Whether the start row is included in the result (default: true)</dd>
<p/>
  <dt>end_row</dt>
  <dd>The row to end scan with. Must not contain nulls</dd>
<p/>
  <dt>end_column</dt>
  <dd>The column (prefix of column_family:column_qualifier) of the
  end row for the scan</dd>
<p/>
  <dt>end_inclusive</dt>
  <dd>Whether the end row is included in the result (default: true)</dd>
</dl>
<br/></div><div class="definition"><h3 id="Struct_ScanSpec">Struct: ScanSpec</h3>
<table><tr><th>Key</th><th>Field</th><th>Type</th><th>Description</th><th>Requiredness</th><th>Default value</th></tr>
<tr><td>1</td><td>row_intervals</td><td><code>list&lt;<code><a href="Client.html#Struct_RowInterval">RowInterval</a></code>&gt;</code></td><td></td><td>optional</td><td></td></tr>
<tr><td>2</td><td>cell_intervals</td><td><code>list&lt;<code><a href="Client.html#Struct_CellInterval">CellInterval</a></code>&gt;</code></td><td></td><td>optional</td><td></td></tr>
<tr><td>3</td><td>return_deletes</td><td><code>bool</code></td><td></td><td>optional</td><td>0</td></tr>
<tr><td>4</td><td>revs</td><td><code>i32</code></td><td></td><td>optional</td><td>0</td></tr>
<tr><td>5</td><td>row_limit</td><td><code>i32</code></td><td></td><td>optional</td><td>0</td></tr>
<tr><td>6</td><td>start_time</td><td><code>i64</code></td><td></td><td>optional</td><td></td></tr>
<tr><td>7</td><td>end_time</td><td><code>i64</code></td><td></td><td>optional</td><td></td></tr>
<tr><td>8</td><td>columns</td><td><code>list&lt;<code>string</code>&gt;</code></td><td></td><td>optional</td><td></td></tr>
<tr><td>9</td><td>keys_only</td><td><code>bool</code></td><td></td><td>optional</td><td>0</td></tr>
<tr><td>10</td><td>cell_limit</td><td><code>i32</code></td><td></td><td>optional</td><td>0</td></tr>
<tr><td>11</td><td>row_regexp</td><td><code>string</code></td><td></td><td>optional</td><td></td></tr>
<tr><td>12</td><td>value_regexp</td><td><code>string</code></td><td></td><td>optional</td><td></td></tr>
<tr><td>13</td><td>scan_and_filter_rows</td><td><code>bool</code></td><td></td><td>optional</td><td>0</td></tr>
</table><br/>Specifies options for a scan
<p/>
<dl>
  <dt>row_intervals</dt>
  <dd>A list of ranges of rows to scan. Mutually exclusive with
  cell_interval</dd>
<p/>
  <dt>cell_intervals</dt>
  <dd>A list of ranges of cells to scan. Mutually exclusive with
  row_intervals</dd>
<p/>
  <dt>return_deletes</dt>
  <dd>Indicates whether cells pending delete are returned</dd>
<p/>
  <dt>revs</dt>
  <dd>Specifies max number of revisions of cells to return</dd>
<p/>
  <dt>row_limit</dt>
  <dd>Specifies max number of rows to return</dd>
<p/>
  <dt>start_time</dt>
  <dd>Specifies start time in nanoseconds since epoch for cells to
  return</dd>
<p/>
  <dt>end_time</dt>
  <dd>Specifies end time in nanoseconds since epoch for cells to return</dd>
<p/>
  <dt>columns</dt>
  <dd>Specifies the names of the columns to return</dd>
<p/>
  <dt>cell_limit</dt>
  <dd>Specifies max number of cells to return per column family per row</dd>
<p/>
  <dt>row_regexp</dt>
  <dd>Specifies a regexp used to filter by rowkey</dd>
<p/>
  <dt>value_regexp</dt>
  <dd>Specifies a regexp used to filter by cell value</dd>
<p/>
  <dt>scan_and_filter_rows</dt>
  <dd>Indicates whether table scan filters the rows specified instead of individual look up</dd>
</dl>
<br/></div><div class="definition"><h3 id="Struct_Key">Struct: Key</h3>
<table><tr><th>Key</th><th>Field</th><th>Type</th><th>Description</th><th>Requiredness</th><th>Default value</th></tr>
<tr><td>1</td><td>row</td><td><code>string</code></td><td></td><td>default</td><td></td></tr>
<tr><td>2</td><td>column_family</td><td><code>string</code></td><td></td><td>default</td><td></td></tr>
<tr><td>3</td><td>column_qualifier</td><td><code>string</code></td><td></td><td>default</td><td></td></tr>
<tr><td>4</td><td>timestamp</td><td><code>i64</code></td><td></td><td>optional</td><td></td></tr>
<tr><td>5</td><td>revision</td><td><code>i64</code></td><td></td><td>optional</td><td></td></tr>
<tr><td>6</td><td>flag</td><td><code><a href="Client.html#Enum_KeyFlag">KeyFlag</a></code></td><td></td><td>default</td><td>UNKNOWN</td></tr>
</table><br/>Defines a cell key
<p/>
<dl>
  <dt>row</dt>
  <dd>Specifies the row key. Note, it cannot contain null characters.
  If a row key is not specified in a return cell, it's assumed to
  be the same as the previous cell</dd>
<p/>
  <dt>column_family</dt>
  <dd>Specifies the column family</dd>
<p/>
  <dt>column_qualifier</dt>
  <dd>Specifies the column qualifier. A column family must be specified.</dd>
<p/>
  <dt>timestamp</dt>
  <dd>Nanoseconds since epoch for the cell<dd>
<p/>
  <dt>revision</dt>
  <dd>A 64-bit revision number for the cell</dd>
<p/>
  <dt>flag</dt>
  <dd>A 16-bit integer indicating the state of the cell</dd>
</dl>
<br/></div><div class="definition"><h3 id="Struct_MutateSpec">Struct: MutateSpec</h3>
<table><tr><th>Key</th><th>Field</th><th>Type</th><th>Description</th><th>Requiredness</th><th>Default value</th></tr>
<tr><td>1</td><td>appname</td><td><code>string</code></td><td></td><td>required</td><td>""</td></tr>
<tr><td>2</td><td>flush_interval</td><td><code>i32</code></td><td></td><td>required</td><td>1000</td></tr>
<tr><td>3</td><td>flags</td><td><code>i32</code></td><td></td><td>required</td><td>2</td></tr>
</table><br/>Specifies options for a shared periodic mutator
<p/>
<dl>
  <dt>appname</dt>
  <dd>String key used to share/retrieve mutator, eg: "my_ht_app"</dd>
<p/>
  <dt>flush_interval</dt>
  <dd>Time interval between flushes</dd>
<p/>
  <dt>flags</dt>
  <dd>Mutator flags</dt>
</dl>
<br/></div><div class="definition"><h3 id="Struct_Cell">Struct: Cell</h3>
<table><tr><th>Key</th><th>Field</th><th>Type</th><th>Description</th><th>Requiredness</th><th>Default value</th></tr>
<tr><td>1</td><td>key</td><td><code><a href="Client.html#Struct_Key">Key</a></code></td><td></td><td>default</td><td></td></tr>
<tr><td>2</td><td>value</td><td><code><a href="Client.html#Typedef_Value">Value</a></code></td><td></td><td>optional</td><td></td></tr>
</table><br/>Defines a table cell
<p/>
<dl>
  <dt>key</dt>
  <dd>Specifies the cell key</dd>
<p/>
  <dt>value</dt>
  <dd>Value of a cell. Currently a sequence of uninterpreted bytes.</dd>
</dl>
<br/></div><div class="definition"><h3 id="Struct_Result">Struct: Result</h3>
<table><tr><th>Key</th><th>Field</th><th>Type</th><th>Description</th><th>Requiredness</th><th>Default value</th></tr>
<tr><td>1</td><td>is_empty</td><td><code>bool</code></td><td></td><td>required</td><td></td></tr>
<tr><td>2</td><td>id</td><td><code>i64</code></td><td></td><td>required</td><td></td></tr>
<tr><td>3</td><td>is_scan</td><td><code>bool</code></td><td></td><td>required</td><td></td></tr>
<tr><td>4</td><td>is_error</td><td><code>bool</code></td><td></td><td>required</td><td></td></tr>
<tr><td>5</td><td>error</td><td><code>i32</code></td><td></td><td>optional</td><td></td></tr>
<tr><td>6</td><td>error_msg</td><td><code>string</code></td><td></td><td>optional</td><td></td></tr>
<tr><td>7</td><td>cells</td><td><code>list&lt;<code><a href="Client.html#Struct_Cell">Cell</a></code>&gt;</code></td><td></td><td>optional</td><td></td></tr>
</table><br/>Specifies a result object for asynchronous requests.
TODO: add support for update results
<p/>
<dl>
  <dt>is_empty</dt>
  <dd>Indicates whether this object contains a result or not</dd>
<p/>
  <dt>id</dt>
  <dd>Scanner/mutator id for which these results pertain to</dd>
  
  <dt>is_scan</dt>
  <dd>Indicates whether these are scan results or update results</dd>
  
  <dt>is_error</dt>
  <dd>Indicates whether the async request was successful or not</dd>
  
  <dt>error</dt>
  <dd>Error code</dd>
<p/>
  <dt>error_msg</dt>
  <dd>Error message</dd>
<p/>
  <dt>cells</dt>
  <dd>Cells returned by asynchronous scanner</dd>
</dl>
<br/></div><div class="definition"><h3 id="Struct_ResultAsArrays">Struct: ResultAsArrays</h3>
<table><tr><th>Key</th><th>Field</th><th>Type</th><th>Description</th><th>Requiredness</th><th>Default value</th></tr>
<tr><td>1</td><td>is_empty</td><td><code>bool</code></td><td></td><td>required</td><td></td></tr>
<tr><td>2</td><td>id</td><td><code>i64</code></td><td></td><td>required</td><td></td></tr>
<tr><td>3</td><td>is_scan</td><td><code>bool</code></td><td></td><td>required</td><td></td></tr>
<tr><td>4</td><td>is_error</td><td><code>bool</code></td><td></td><td>required</td><td></td></tr>
<tr><td>5</td><td>error</td><td><code>i32</code></td><td></td><td>optional</td><td></td></tr>
<tr><td>6</td><td>error_msg</td><td><code>string</code></td><td></td><td>optional</td><td></td></tr>
<tr><td>7</td><td>cells</td><td><code>list&lt;<code><a href="Client.html#Typedef_CellAsArray">CellAsArray</a></code>&gt;</code></td><td></td><td>optional</td><td></td></tr>
</table><br/>Specifies a result object for asynchronous requests.
TODO: add support for update results
<p/>
<dl>
  <dt>is_empty</dt>
  <dd>Indicates whether this object contains a result or not</dd>
<p/>
  <dt>id</dt>
  <dd>Scanner/mutator id for which these results pertain to</dd>
  
  <dt>is_scan</dt>
  <dd>Indicates whether these are scan results or update results</dd>
  
  <dt>is_error</dt>
  <dd>Indicates whether the async request was successful or not</dd>
  
  <dt>error</dt>
  <dd>Error code</dd>
<p/>
  <dt>error_msg</dt>
  <dd>Error message</dd>
<p/>
  <dt>cells</dt>
  <dd>Cells returned by asynchronous scanner</dd>
</dl>
<br/></div><div class="definition"><h3 id="Struct_ResultSerialized">Struct: ResultSerialized</h3>
<table><tr><th>Key</th><th>Field</th><th>Type</th><th>Description</th><th>Requiredness</th><th>Default value</th></tr>
<tr><td>1</td><td>is_empty</td><td><code>bool</code></td><td></td><td>required</td><td></td></tr>
<tr><td>2</td><td>id</td><td><code>i64</code></td><td></td><td>required</td><td></td></tr>
<tr><td>3</td><td>is_scan</td><td><code>bool</code></td><td></td><td>required</td><td></td></tr>
<tr><td>4</td><td>is_error</td><td><code>bool</code></td><td></td><td>required</td><td></td></tr>
<tr><td>5</td><td>error</td><td><code>i32</code></td><td></td><td>optional</td><td></td></tr>
<tr><td>6</td><td>error_msg</td><td><code>string</code></td><td></td><td>optional</td><td></td></tr>
<tr><td>7</td><td>cells</td><td><code><a href="Client.html#Typedef_CellsSerialized">CellsSerialized</a></code></td><td></td><td>optional</td><td></td></tr>
</table><br/>Specifies a serialized result object for asynchronous requests.
TODO: add support for update results
<p/>
<dl>
  <dt>is_empty</dt>
  <dd>Indicates whether this object contains a result or not</dd>
<p/>
  <dt>id</dt>
  <dd>Scanner/mutator id for which these results pertain to</dd>
  
  <dt>is_scan</dt>
  <dd>Indicates whether these are scan results or update results</dd>
  
  <dt>is_error</dt>
  <dd>Indicates whether the async request was successful or not</dd>
  
  <dt>error</dt>
  <dd>Error code</dd>
<p/>
  <dt>error_msg</dt>
  <dd>Error message</dd>
<p/>
  <dt>cells</dt>
  <dd>Cells returned by asynchronous scanner</dd>
</dl>
<br/></div><div class="definition"><h3 id="Struct_NamespaceListing">Struct: NamespaceListing</h3>
<table><tr><th>Key</th><th>Field</th><th>Type</th><th>Description</th><th>Requiredness</th><th>Default value</th></tr>
<tr><td>1</td><td>name</td><td><code>string</code></td><td></td><td>required</td><td></td></tr>
<tr><td>2</td><td>is_namespace</td><td><code>bool</code></td><td></td><td>required</td><td></td></tr>
</table><br/>Defines an individual namespace listing
<p/>
<dl>
  <dt>name</dt>
  <dd>Name of the listing.</dd>
<p/>
  <dt>is_namespace</dt>
  <dd>true if this entry is a namespace.</dd>
</dl>
<br/></div><div class="definition"><h3 id="Struct_TableSplit">Struct: TableSplit</h3>
<table><tr><th>Key</th><th>Field</th><th>Type</th><th>Description</th><th>Requiredness</th><th>Default value</th></tr>
<tr><td>1</td><td>start_row</td><td><code>string</code></td><td></td><td>optional</td><td></td></tr>
<tr><td>2</td><td>end_row</td><td><code>string</code></td><td></td><td>optional</td><td></td></tr>
<tr><td>3</td><td>location</td><td><code>string</code></td><td></td><td>optional</td><td></td></tr>
<tr><td>4</td><td>ip_address</td><td><code>string</code></td><td></td><td>optional</td><td></td></tr>
<tr><td>5</td><td>hostname</td><td><code>string</code></td><td></td><td>optional</td><td></td></tr>
</table><br/>Defines a table split
<p/>
<dl>
  <dt>start_row</dt>
  <dd>Starting row of the split.</dd>
<p/>
  <dt>end_row</dt>
  <dd>Ending row of the split.</dd>
<p/>
  <dt>location</dt>
  <dd>Location (proxy name) of the split.</dd>
<p/>
  <dt>ip_address</dt>
  <dd>The IP address of the split.</dd>
<p/>
  <dt>hostname</dt>
  <dd>The hostname of the split.</dd>
</dl>
<br/></div><div class="definition"><h3 id="Struct_ColumnFamily">Struct: ColumnFamily</h3>
<table><tr><th>Key</th><th>Field</th><th>Type</th><th>Description</th><th>Requiredness</th><th>Default value</th></tr>
<tr><td>1</td><td>name</td><td><code>string</code></td><td></td><td>optional</td><td></td></tr>
<tr><td>2</td><td>ag</td><td><code>string</code></td><td></td><td>optional</td><td></td></tr>
<tr><td>3</td><td>max_versions</td><td><code>i32</code></td><td></td><td>optional</td><td></td></tr>
<tr><td>4</td><td>ttl</td><td><code>string</code></td><td></td><td>optional</td><td></td></tr>
</table><br/>Describes a ColumnFamily
<dl>
  <dt>name</dt>
  <dd>Name of the column family</dd>
<p/>
  <dt>ag</dt>
  <dd>Name of the access group for this CF</dd>
<p/>
  <dt>max_versions</dt>
  <dd>Max versions of the same cell to be stored</dd>
<p/>
  <dt>ttl</dt>
  <dd>Time to live for cells in the CF (ie delete cells older than this time)</dd>
</dl>
<br/></div><div class="definition"><h3 id="Struct_AccessGroup">Struct: AccessGroup</h3>
<table><tr><th>Key</th><th>Field</th><th>Type</th><th>Description</th><th>Requiredness</th><th>Default value</th></tr>
<tr><td>1</td><td>name</td><td><code>string</code></td><td></td><td>optional</td><td></td></tr>
<tr><td>2</td><td>in_memory</td><td><code>bool</code></td><td></td><td>optional</td><td></td></tr>
<tr><td>3</td><td>replication</td><td><code>i16</code></td><td></td><td>optional</td><td></td></tr>
<tr><td>4</td><td>blocksize</td><td><code>i32</code></td><td></td><td>optional</td><td></td></tr>
<tr><td>5</td><td>compressor</td><td><code>string</code></td><td></td><td>optional</td><td></td></tr>
<tr><td>6</td><td>bloom_filter</td><td><code>string</code></td><td></td><td>optional</td><td></td></tr>
<tr><td>7</td><td>columns</td><td><code>list&lt;<code><a href="Client.html#Struct_ColumnFamily">ColumnFamily</a></code>&gt;</code></td><td></td><td>optional</td><td></td></tr>
</table><br/>Describes an AccessGroup
<dl>
  <dt>name</dt>
  <dd>Name of the access group</dd>
<p/>
  <dt>in_memory</dt>
  <dd>Is this access group in memory</dd>
<p/>
  <dt>replication</dt>
  <dd>Replication factor for this AG</dd>
<p/>
  <dt>blocksize</dt>
  <dd>Specifies blocksize for this AG</dd>
<p/>
  <dt>compressor</dt>
  <dd>Specifies compressor for this AG</dd>
<p/>
  <dt>bloom_filter</dt>
  <dd>Specifies bloom filter type</dd>
<p/>
  <dt>columns</dt>
  <dd>Specifies list of column families in this AG</dd>
</dl>
<br/></div><div class="definition"><h3 id="Struct_Schema">Struct: Schema</h3>
<table><tr><th>Key</th><th>Field</th><th>Type</th><th>Description</th><th>Requiredness</th><th>Default value</th></tr>
<tr><td>1</td><td>access_groups</td><td><code>map&lt;<code>string</code>, <code><a href="Client.html#Struct_AccessGroup">AccessGroup</a></code>&gt;</code></td><td></td><td>optional</td><td></td></tr>
<tr><td>2</td><td>column_families</td><td><code>map&lt;<code>string</code>, <code><a href="Client.html#Struct_ColumnFamily">ColumnFamily</a></code>&gt;</code></td><td></td><td>optional</td><td></td></tr>
</table><br/>Describes a schema
<dl>
  <dt>name</dt>
  <dd>Name of the access group</dd>
<p/>
  <dt>in_memory</dt>
  <dd>Is this access group in memory</dd>
<p/>
  <dt>replication</dt>
  <dd>Replication factor for this AG</dd>
<p/>
  <dt>blocksize</dt>
  <dd>Specifies blocksize for this AG</dd>
<p/>
  <dt>compressor</dt>
  <dd>Specifies compressor for this AG</dd>
<p/>
  <dt>bloom_filter</dt>
  <dd>Specifies bloom filter type</dd>
<p/>
  <dt>columns</dt>
  <dd>Specifies list of column families in this AG</dd>
</dl>
<br/></div><div class="definition"><h3 id="Struct_ClientException">Exception: ClientException</h3>
<table><tr><th>Key</th><th>Field</th><th>Type</th><th>Description</th><th>Requiredness</th><th>Default value</th></tr>
<tr><td>1</td><td>code</td><td><code>i32</code></td><td></td><td>default</td><td></td></tr>
<tr><td>2</td><td>message</td><td><code>string</code></td><td></td><td>default</td><td></td></tr>
</table><br/>Exception for thrift clients.
<p/>
<dl>
  <dt>code</dt><dd>Internal use (defined in src/cc/Common/Error.h)</dd>
  <dt>message</dt><dd>A message about the exception</dd>
</dl>
<p/>
Note: some languages (like php) don't have adequate namespace, so Exception
would conflict with language builtins.
<br/></div><hr/><h2 id="Services">Services</h2>
<h3 id="Svc_ClientService">Service: ClientService</h3>
The client service mimics the C++ client API, with table, scanner and
mutator interface flattened.
<br/><div class="definition"><h4 id="Fn_ClientService_create_namespace">Function: ClientService.create_namespace</h4>
<pre><code>void</code> create_namespace(<code>string</code> ns)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Create a namespace
<p/>
@param ns - namespace name
<br/></div><div class="definition"><h4 id="Fn_ClientService_create_table">Function: ClientService.create_table</h4>
<pre><code>void</code> create_table(<code><a href="Client.html#Typedef_Namespace">Namespace</a></code> ns,
                  <code>string</code> table_name,
                  <code>string</code> schema)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Create a table
<p/>
@param ns - namespace id
@param table_name - table name
@param schema - schema of the table (in xml)
<br/></div><div class="definition"><h4 id="Fn_ClientService_alter_table">Function: ClientService.alter_table</h4>
<pre><code>void</code> alter_table(<code><a href="Client.html#Typedef_Namespace">Namespace</a></code> ns,
                 <code>string</code> table_name,
                 <code>string</code> schema)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Alter a table
<p/>
@param ns - namespace id
@param table_name - table name
@param schema - schema of the table (in xml)
<br/></div><div class="definition"><h4 id="Fn_ClientService_open_namespace">Function: ClientService.open_namespace</h4>
<pre><code><a href="Client.html#Typedef_Namespace">Namespace</a></code> open_namespace(<code>string</code> ns)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Open a namespace
<p/>
@param ns - namespace
@return value is guaranteed to be non-zero and unique
<br/></div><div class="definition"><h4 id="Fn_ClientService_close_namespace">Function: ClientService.close_namespace</h4>
<pre><code>void</code> close_namespace(<code><a href="Client.html#Typedef_Namespace">Namespace</a></code> ns)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Close a namespace
<p/>
@param ns - namespace
<br/></div><div class="definition"><h4 id="Fn_ClientService_open_future">Function: ClientService.open_future</h4>
<pre><code><a href="Client.html#Typedef_Future">Future</a></code> open_future(<code>i32</code> queue_size = 0)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Open a future object
@param queue_size - num of results the future object can enqueue without blocking threads
<br/></div><div class="definition"><h4 id="Fn_ClientService_cancel_future">Function: ClientService.cancel_future</h4>
<pre><code>void</code> cancel_future(<code><a href="Client.html#Typedef_Future">Future</a></code> ff)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Cancel tasks outstanding in a future object
@param ff - Future object
<br/></div><div class="definition"><h4 id="Fn_ClientService_get_future_result">Function: ClientService.get_future_result</h4>
<pre><code><a href="Client.html#Struct_Result">Result</a></code> get_future_result(<code><a href="Client.html#Typedef_Future">Future</a></code> ff)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Fetch asynchronous results
@param ff - Future object which has the asynchronous results
@return - result from async scanner/mutator
<br/></div><div class="definition"><h4 id="Fn_ClientService_get_future_result_as_arrays">Function: ClientService.get_future_result_as_arrays</h4>
<pre><code><a href="Client.html#Struct_ResultAsArrays">ResultAsArrays</a></code> get_future_result_as_arrays(<code><a href="Client.html#Typedef_Future">Future</a></code> ff)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Fetch asynchronous results
@param ff - Future object which has the asynchronous results
@return - result from async scanner/mutator
<br/></div><div class="definition"><h4 id="Fn_ClientService_get_future_result_serialized">Function: ClientService.get_future_result_serialized</h4>
<pre><code><a href="Client.html#Struct_ResultSerialized">ResultSerialized</a></code> get_future_result_serialized(<code><a href="Client.html#Typedef_Future">Future</a></code> ff)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Fetch asynchronous results
@param ff - Future object which has the asynchronous results
@return - result from async scanner/mutator
<br/></div><div class="definition"><h4 id="Fn_ClientService_future_is_empty">Function: ClientService.future_is_empty</h4>
<pre><code>bool</code> future_is_empty(<code><a href="Client.html#Typedef_Future">Future</a></code> ff)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Check if future object's queue is empty
<br/></div><div class="definition"><h4 id="Fn_ClientService_future_is_full">Function: ClientService.future_is_full</h4>
<pre><code>bool</code> future_is_full(<code><a href="Client.html#Typedef_Future">Future</a></code> ff)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Check if future object's queue is full
<br/></div><div class="definition"><h4 id="Fn_ClientService_future_is_cancelled">Function: ClientService.future_is_cancelled</h4>
<pre><code>bool</code> future_is_cancelled(<code><a href="Client.html#Typedef_Future">Future</a></code> ff)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Check if future object has been cancelled
<br/></div><div class="definition"><h4 id="Fn_ClientService_future_has_outstanding">Function: ClientService.future_has_outstanding</h4>
<pre><code>bool</code> future_has_outstanding(<code><a href="Client.html#Typedef_Future">Future</a></code> ff)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Check if future object has outstanding operations
<br/></div><div class="definition"><h4 id="Fn_ClientService_close_future">Function: ClientService.close_future</h4>
<pre><code>void</code> close_future(<code><a href="Client.html#Typedef_Future">Future</a></code> ff)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Close a future object
@param ff - the future object to be closed
<br/></div><div class="definition"><h4 id="Fn_ClientService_open_scanner">Function: ClientService.open_scanner</h4>
<pre><code><a href="Client.html#Typedef_Scanner">Scanner</a></code> open_scanner(<code><a href="Client.html#Typedef_Namespace">Namespace</a></code> ns,
                     <code>string</code> table_name,
                     <code><a href="Client.html#Struct_ScanSpec">ScanSpec</a></code> scan_spec)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Open a table scanner
@param ns - namespace id
@param table_name - table name
@param scan_spec - scan specification
<br/></div><div class="definition"><h4 id="Fn_ClientService_open_scanner_async">Function: ClientService.open_scanner_async</h4>
<pre><code><a href="Client.html#Typedef_ScannerAsync">ScannerAsync</a></code> open_scanner_async(<code><a href="Client.html#Typedef_Namespace">Namespace</a></code> ns,
                                <code>string</code> table_name,
                                <code><a href="Client.html#Typedef_Future">Future</a></code> future,
                                <code><a href="Client.html#Struct_ScanSpec">ScanSpec</a></code> scan_spec)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Open an asynchronous table scanner
@param ns - namespace id
@param table_name - table name
@param future - callback object
@param scan_spec - scan specification
<br/></div><div class="definition"><h4 id="Fn_ClientService_close_scanner">Function: ClientService.close_scanner</h4>
<pre><code>void</code> close_scanner(<code><a href="Client.html#Typedef_Scanner">Scanner</a></code> scanner)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Close a table scanner
<p/>
@param scanner - scanner id to close
<br/></div><div class="definition"><h4 id="Fn_ClientService_close_scanner_async">Function: ClientService.close_scanner_async</h4>
<pre><code>void</code> close_scanner_async(<code><a href="Client.html#Typedef_ScannerAsync">ScannerAsync</a></code> scanner)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Close a table scanner
<p/>
@param scanner - scanner id to close
<br/></div><div class="definition"><h4 id="Fn_ClientService_next_cells">Function: ClientService.next_cells</h4>
<pre><code>list&lt;<code><a href="Client.html#Struct_Cell">Cell</a></code>&gt;</code> next_cells(<code><a href="Client.html#Typedef_Scanner">Scanner</a></code> scanner)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Iterate over cells of a scanner
<p/>
@param scanner - scanner id
<br/></div><div class="definition"><h4 id="Fn_ClientService_next_cells_as_arrays">Function: ClientService.next_cells_as_arrays</h4>
<pre><code>list&lt;<code><a href="Client.html#Typedef_CellAsArray">CellAsArray</a></code>&gt;</code> next_cells_as_arrays(<code><a href="Client.html#Typedef_Scanner">Scanner</a></code> scanner)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre></div><div class="definition"><h4 id="Fn_ClientService_next_cells_serialized">Function: ClientService.next_cells_serialized</h4>
<pre><code><a href="Client.html#Typedef_CellsSerialized">CellsSerialized</a></code> next_cells_serialized(<code><a href="Client.html#Typedef_Scanner">Scanner</a></code> scanner)
</pre>Alternative interface returning buffer of serialized cells
<br/></div><div class="definition"><h4 id="Fn_ClientService_next_row">Function: ClientService.next_row</h4>
<pre><code>list&lt;<code><a href="Client.html#Struct_Cell">Cell</a></code>&gt;</code> next_row(<code><a href="Client.html#Typedef_Scanner">Scanner</a></code> scanner)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Iterate over rows of a scanner
<p/>
@param scanner - scanner id
<br/></div><div class="definition"><h4 id="Fn_ClientService_next_row_as_arrays">Function: ClientService.next_row_as_arrays</h4>
<pre><code>list&lt;<code><a href="Client.html#Typedef_CellAsArray">CellAsArray</a></code>&gt;</code> next_row_as_arrays(<code><a href="Client.html#Typedef_Scanner">Scanner</a></code> scanner)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Alternative interface using array as cell
<br/></div><div class="definition"><h4 id="Fn_ClientService_next_row_serialized">Function: ClientService.next_row_serialized</h4>
<pre><code><a href="Client.html#Typedef_CellsSerialized">CellsSerialized</a></code> next_row_serialized(<code><a href="Client.html#Typedef_Scanner">Scanner</a></code> scanner)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Alternate interface returning a buffer of serialized cells for iterating by row
for a given scanner
<p/>
@param scanner - scanner id
<br/></div><div class="definition"><h4 id="Fn_ClientService_get_row">Function: ClientService.get_row</h4>
<pre><code>list&lt;<code><a href="Client.html#Struct_Cell">Cell</a></code>&gt;</code> get_row(<code><a href="Client.html#Typedef_Namespace">Namespace</a></code> ns,
                   <code>string</code> table_name,
                   <code>string</code> row)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Get a row (convenience method for random access a row)
<p/>
@param ns - namespace id
<p/>
@param table_name - table name
<p/>
@param row - row key
<p/>
@return a list of cells (with row_keys unset)
<br/></div><div class="definition"><h4 id="Fn_ClientService_get_row_as_arrays">Function: ClientService.get_row_as_arrays</h4>
<pre><code>list&lt;<code><a href="Client.html#Typedef_CellAsArray">CellAsArray</a></code>&gt;</code> get_row_as_arrays(<code><a href="Client.html#Typedef_Namespace">Namespace</a></code> ns,
                                    <code>string</code> name,
                                    <code>string</code> row)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Alternative interface using array as cell
<br/></div><div class="definition"><h4 id="Fn_ClientService_get_row_serialized">Function: ClientService.get_row_serialized</h4>
<pre><code><a href="Client.html#Typedef_CellsSerialized">CellsSerialized</a></code> get_row_serialized(<code><a href="Client.html#Typedef_Namespace">Namespace</a></code> ns,
                                   <code>string</code> table_name,
                                   <code>string</code> row)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Alternative interface returning buffer of serialized cells
<br/></div><div class="definition"><h4 id="Fn_ClientService_get_cell">Function: ClientService.get_cell</h4>
<pre><code><a href="Client.html#Typedef_Value">Value</a></code> get_cell(<code><a href="Client.html#Typedef_Namespace">Namespace</a></code> ns,
               <code>string</code> table_name,
               <code>string</code> row,
               <code>string</code> column)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Get a cell (convenience method for random access a cell)
<p/>
@param ns - namespace id
<p/>
@param table_name - table name
<p/>
@param row - row key
<p/>
@param column - column name
<p/>
@return value (byte sequence)
<br/></div><div class="definition"><h4 id="Fn_ClientService_get_cells">Function: ClientService.get_cells</h4>
<pre><code>list&lt;<code><a href="Client.html#Struct_Cell">Cell</a></code>&gt;</code> get_cells(<code><a href="Client.html#Typedef_Namespace">Namespace</a></code> ns,
                     <code>string</code> table_name,
                     <code><a href="Client.html#Struct_ScanSpec">ScanSpec</a></code> scan_spec)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Get cells (convenience method for access small amount of cells)
<p/>
@param ns - namespace id
 
@param table_name - table name
<p/>
@param scan_spec - scan specification
<p/>
@return a list of cells (a cell with no row key set is assumed to have
        the same row key as the previous cell)
<br/></div><div class="definition"><h4 id="Fn_ClientService_get_cells_as_arrays">Function: ClientService.get_cells_as_arrays</h4>
<pre><code>list&lt;<code><a href="Client.html#Typedef_CellAsArray">CellAsArray</a></code>&gt;</code> get_cells_as_arrays(<code><a href="Client.html#Typedef_Namespace">Namespace</a></code> ns,
                                      <code>string</code> name,
                                      <code><a href="Client.html#Struct_ScanSpec">ScanSpec</a></code> scan_spec)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Alternative interface using array as cell
<br/></div><div class="definition"><h4 id="Fn_ClientService_get_cells_serialized">Function: ClientService.get_cells_serialized</h4>
<pre><code><a href="Client.html#Typedef_CellsSerialized">CellsSerialized</a></code> get_cells_serialized(<code><a href="Client.html#Typedef_Namespace">Namespace</a></code> ns,
                                     <code>string</code> name,
                                     <code><a href="Client.html#Struct_ScanSpec">ScanSpec</a></code> scan_spec)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Alternative interface returning buffer of serialized cells
<br/></div><div class="definition"><h4 id="Fn_ClientService_refresh_shared_mutator">Function: ClientService.refresh_shared_mutator</h4>
<pre><code>void</code> refresh_shared_mutator(<code><a href="Client.html#Typedef_Namespace">Namespace</a></code> ns,
                            <code>string</code> table_name,
                            <code><a href="Client.html#Struct_MutateSpec">MutateSpec</a></code> mutate_spec)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Create a shared mutator with specified MutateSpec.
Delete and recreate it if the mutator exists.
<p/>
@param ns - namespace id
 
@param table_name - table name
<p/>
@param mutate_spec - mutator specification
<p/>
<br/></div><div class="definition"><h4 id="Fn_ClientService_offer_cells">Function: ClientService.offer_cells</h4>
<pre><code>void</code> offer_cells(<code><a href="Client.html#Typedef_Namespace">Namespace</a></code> ns,
                 <code>string</code> table_name,
                 <code><a href="Client.html#Struct_MutateSpec">MutateSpec</a></code> mutate_spec,
                 <code>list&lt;<code><a href="Client.html#Struct_Cell">Cell</a></code>&gt;</code> cells)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Open a shared periodic mutator which causes cells to be written asyncronously.
Users beware: calling this method merely writes
cells to a local buffer and does not guarantee that the cells have been persisted.
If you want guaranteed durability, use the open_mutator+set_cells* interface instead.
<p/>
@param ns - namespace id
<p/>
@param table_name - table name
<p/>
@param mutate_spec - mutator specification
<p/>
@param cells - set of cells to be written
<br/></div><div class="definition"><h4 id="Fn_ClientService_offer_cells_as_arrays">Function: ClientService.offer_cells_as_arrays</h4>
<pre><code>void</code> offer_cells_as_arrays(<code><a href="Client.html#Typedef_Namespace">Namespace</a></code> ns,
                           <code>string</code> table_name,
                           <code><a href="Client.html#Struct_MutateSpec">MutateSpec</a></code> mutate_spec,
                           <code>list&lt;<code><a href="Client.html#Typedef_CellAsArray">CellAsArray</a></code>&gt;</code> cells)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Alternative to offer_cell interface using array as cell
<br/></div><div class="definition"><h4 id="Fn_ClientService_offer_cell">Function: ClientService.offer_cell</h4>
<pre><code>void</code> offer_cell(<code><a href="Client.html#Typedef_Namespace">Namespace</a></code> ns,
                <code>string</code> table_name,
                <code><a href="Client.html#Struct_MutateSpec">MutateSpec</a></code> mutate_spec,
                <code><a href="Client.html#Struct_Cell">Cell</a></code> cell)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Open a shared periodic mutator which causes cells to be written asyncronously.
Users beware: calling this method merely writes
cells to a local buffer and does not guarantee that the cells have been persisted.
If you want guaranteed durability, use the open_mutator+set_cells* interface instead.
<p/>
@param ns - namespace id
<p/>
@param table_name - table name
<p/>
@param mutate_spec - mutator specification
<p/>
@param cell - cell to be written
<br/></div><div class="definition"><h4 id="Fn_ClientService_offer_cell_as_array">Function: ClientService.offer_cell_as_array</h4>
<pre><code>void</code> offer_cell_as_array(<code><a href="Client.html#Typedef_Namespace">Namespace</a></code> ns,
                         <code>string</code> table_name,
                         <code><a href="Client.html#Struct_MutateSpec">MutateSpec</a></code> mutate_spec,
                         <code><a href="Client.html#Typedef_CellAsArray">CellAsArray</a></code> cell)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Alternative to offer_cell interface using array as cell
<br/></div><div class="definition"><h4 id="Fn_ClientService_open_mutator">Function: ClientService.open_mutator</h4>
<pre><code><a href="Client.html#Typedef_Mutator">Mutator</a></code> open_mutator(<code><a href="Client.html#Typedef_Namespace">Namespace</a></code> ns,
                     <code>string</code> table_name,
                     <code>i32</code> flags = 0,
                     <code>i32</code> flush_interval = 0)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Open a table mutator
<p/>
@param ns - namespace id
<p/>
@param table_name - table name
<p/>
@param flags - mutator flags
<p/>
@param flush_interval - auto-flush interval in milliseconds; 0 disables it.
<p/>
@return mutator id
<br/></div><div class="definition"><h4 id="Fn_ClientService_open_mutator_async">Function: ClientService.open_mutator_async</h4>
<pre><code><a href="Client.html#Typedef_MutatorAsync">MutatorAsync</a></code> open_mutator_async(<code><a href="Client.html#Typedef_Namespace">Namespace</a></code> ns,
                                <code>string</code> table_name,
                                <code><a href="Client.html#Typedef_Future">Future</a></code> future,
                                <code>i32</code> flags = 0)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Open an asynchronous table mutator
<p/>
@param ns - namespace id
@param table_name - table name
@param future - callback object
@param flags - mutator flags
<p/>
@return mutator id
<br/></div><div class="definition"><h4 id="Fn_ClientService_close_mutator">Function: ClientService.close_mutator</h4>
<pre><code>void</code> close_mutator(<code><a href="Client.html#Typedef_Mutator">Mutator</a></code> mutator,
                   <code>bool</code> flush = 1)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Close a table mutator
<p/>
@param mutator - mutator id to close
<br/></div><div class="definition"><h4 id="Fn_ClientService_close_mutator_async">Function: ClientService.close_mutator_async</h4>
<pre><code>void</code> close_mutator_async(<code><a href="Client.html#Typedef_MutatorAsync">MutatorAsync</a></code> mutator)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Close an asynchronous table mutator
<p/>
@param mutator - mutator id to close
<br/></div><div class="definition"><h4 id="Fn_ClientService_set_cell">Function: ClientService.set_cell</h4>
<pre><code>void</code> set_cell(<code><a href="Client.html#Typedef_Mutator">Mutator</a></code> mutator,
              <code><a href="Client.html#Struct_Cell">Cell</a></code> cell)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Set a cell in the table
<p/>
@param mutator - mutator id
<p/>
@param cell - the cell to set
<br/></div><div class="definition"><h4 id="Fn_ClientService_set_cell_as_array">Function: ClientService.set_cell_as_array</h4>
<pre><code>void</code> set_cell_as_array(<code><a href="Client.html#Typedef_Mutator">Mutator</a></code> mutator,
                       <code><a href="Client.html#Typedef_CellAsArray">CellAsArray</a></code> cell)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Alternative interface using array as cell
<br/></div><div class="definition"><h4 id="Fn_ClientService_set_cells">Function: ClientService.set_cells</h4>
<pre><code>void</code> set_cells(<code><a href="Client.html#Typedef_Mutator">Mutator</a></code> mutator,
               <code>list&lt;<code><a href="Client.html#Struct_Cell">Cell</a></code>&gt;</code> cells)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Put a list of cells into a table
<p/>
@param mutator - mutator id
<p/>
@param cells - a list of cells (a cell with no row key set is assumed
       to have the same row key as the previous cell)
<br/></div><div class="definition"><h4 id="Fn_ClientService_set_cells_as_arrays">Function: ClientService.set_cells_as_arrays</h4>
<pre><code>void</code> set_cells_as_arrays(<code><a href="Client.html#Typedef_Mutator">Mutator</a></code> mutator,
                         <code>list&lt;<code><a href="Client.html#Typedef_CellAsArray">CellAsArray</a></code>&gt;</code> cells)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Alternative interface using array as cell
<br/></div><div class="definition"><h4 id="Fn_ClientService_set_cells_serialized">Function: ClientService.set_cells_serialized</h4>
<pre><code>void</code> set_cells_serialized(<code><a href="Client.html#Typedef_Mutator">Mutator</a></code> mutator,
                          <code><a href="Client.html#Typedef_CellsSerialized">CellsSerialized</a></code> cells,
                          <code>bool</code> flush = 0)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Alternative interface using buffer of serialized cells
<br/></div><div class="definition"><h4 id="Fn_ClientService_flush_mutator">Function: ClientService.flush_mutator</h4>
<pre><code>void</code> flush_mutator(<code><a href="Client.html#Typedef_Mutator">Mutator</a></code> mutator)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Flush mutator buffers
<br/></div><div class="definition"><h4 id="Fn_ClientService_set_cell_async">Function: ClientService.set_cell_async</h4>
<pre><code>void</code> set_cell_async(<code><a href="Client.html#Typedef_MutatorAsync">MutatorAsync</a></code> mutator,
                    <code><a href="Client.html#Struct_Cell">Cell</a></code> cell)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Set a cell in the table using an asynchonous mutator
<p/>
@param mutator - mutator id
<p/>
@param cell - the cell to set
<br/></div><div class="definition"><h4 id="Fn_ClientService_set_cell_as_array_async">Function: ClientService.set_cell_as_array_async</h4>
<pre><code>void</code> set_cell_as_array_async(<code><a href="Client.html#Typedef_MutatorAsync">MutatorAsync</a></code> mutator,
                             <code><a href="Client.html#Typedef_CellAsArray">CellAsArray</a></code> cell)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Alternative interface using array as cell using an asynchonous mutator
<br/></div><div class="definition"><h4 id="Fn_ClientService_set_cells_async">Function: ClientService.set_cells_async</h4>
<pre><code>void</code> set_cells_async(<code><a href="Client.html#Typedef_MutatorAsync">MutatorAsync</a></code> mutator,
                     <code>list&lt;<code><a href="Client.html#Struct_Cell">Cell</a></code>&gt;</code> cells)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Put a list of cells into a table using asynchonous mutator
<p/>
@param mutator - mutator id
<p/>
@param cells - a list of cells (a cell with no row key set is assumed
       to have the same row key as the previous cell)
<br/></div><div class="definition"><h4 id="Fn_ClientService_set_cells_as_arrays_async">Function: ClientService.set_cells_as_arrays_async</h4>
<pre><code>void</code> set_cells_as_arrays_async(<code><a href="Client.html#Typedef_MutatorAsync">MutatorAsync</a></code> mutator,
                               <code>list&lt;<code><a href="Client.html#Typedef_CellAsArray">CellAsArray</a></code>&gt;</code> cells)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Alternative interface using array as cell
<br/></div><div class="definition"><h4 id="Fn_ClientService_set_cells_serialized_async">Function: ClientService.set_cells_serialized_async</h4>
<pre><code>void</code> set_cells_serialized_async(<code><a href="Client.html#Typedef_MutatorAsync">MutatorAsync</a></code> mutator,
                                <code><a href="Client.html#Typedef_CellsSerialized">CellsSerialized</a></code> cells,
                                <code>bool</code> flush = 0)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Alternative interface using buffer of serialized cells
<br/></div><div class="definition"><h4 id="Fn_ClientService_flush_mutator_async">Function: ClientService.flush_mutator_async</h4>
<pre><code>void</code> flush_mutator_async(<code><a href="Client.html#Typedef_MutatorAsync">MutatorAsync</a></code> mutator)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Flush mutator buffers
<br/></div><div class="definition"><h4 id="Fn_ClientService_exists_namespace">Function: ClientService.exists_namespace</h4>
<pre><code>bool</code> exists_namespace(<code>string</code> ns)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Check if the namespace exists
<p/>
@param ns - namespace name
<p/>
@return true if ns exists, false ow
<br/></div><div class="definition"><h4 id="Fn_ClientService_exists_table">Function: ClientService.exists_table</h4>
<pre><code>bool</code> exists_table(<code><a href="Client.html#Typedef_Namespace">Namespace</a></code> ns,
                  <code>string</code> name)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Check if the table exists
<p/>
@param ns - namespace id
<p/>
@param name - table name
<p/>
@return true if table exists, false ow
<br/></div><div class="definition"><h4 id="Fn_ClientService_get_table_id">Function: ClientService.get_table_id</h4>
<pre><code>string</code> get_table_id(<code><a href="Client.html#Typedef_Namespace">Namespace</a></code> ns,
                    <code>string</code> table_name)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Get the id of a table
<p/>
@param ns - namespace id
<p/>
@param table_name - table name
<p/>
@return table id string
<br/></div><div class="definition"><h4 id="Fn_ClientService_get_schema_str">Function: ClientService.get_schema_str</h4>
<pre><code>string</code> get_schema_str(<code><a href="Client.html#Typedef_Namespace">Namespace</a></code> ns,
                      <code>string</code> table_name)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Get the schema of a table as a string (that can be used with create_table)
<p/>
@param ns - namespace id
<p/>
@param table_name - table name
<p/>
@return schema string (in xml)
<br/></div><div class="definition"><h4 id="Fn_ClientService_get_schema_str_with_ids">Function: ClientService.get_schema_str_with_ids</h4>
<pre><code>string</code> get_schema_str_with_ids(<code><a href="Client.html#Typedef_Namespace">Namespace</a></code> ns,
                               <code>string</code> table_name)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Get the schema of a table as a string along with column family ids
<p/>
@param ns - namespace id
<p/>
@param table_name - table name
<p/>
@return schema string (in xml)
<br/></div><div class="definition"><h4 id="Fn_ClientService_get_schema">Function: ClientService.get_schema</h4>
<pre><code><a href="Client.html#Struct_Schema">Schema</a></code> get_schema(<code><a href="Client.html#Typedef_Namespace">Namespace</a></code> ns,
                  <code>string</code> table_name)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Get the schema of a table as a string (that can be used with create_table)
  
@param ns - namespace id
<p/>
@param table_name - table name
<p/>
@return schema object describing a table
<br/></div><div class="definition"><h4 id="Fn_ClientService_get_tables">Function: ClientService.get_tables</h4>
<pre><code>list&lt;<code>string</code>&gt;</code> get_tables(<code><a href="Client.html#Typedef_Namespace">Namespace</a></code> ns)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Get a list of table names in the namespace
<p/>
@param ns - namespace id
<p/>
@return a list of table names
<br/></div><div class="definition"><h4 id="Fn_ClientService_get_listing">Function: ClientService.get_listing</h4>
<pre><code>list&lt;<code><a href="Client.html#Struct_NamespaceListing">NamespaceListing</a></code>&gt;</code> get_listing(<code><a href="Client.html#Typedef_Namespace">Namespace</a></code> ns)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Get a list of namespaces and table names table names in the namespace
<p/>
@param ns - namespace
<p/>
@return a list of table names
<br/></div><div class="definition"><h4 id="Fn_ClientService_get_table_splits">Function: ClientService.get_table_splits</h4>
<pre><code>list&lt;<code><a href="Client.html#Struct_TableSplit">TableSplit</a></code>&gt;</code> get_table_splits(<code><a href="Client.html#Typedef_Namespace">Namespace</a></code> ns,
                                  <code>string</code> table_name)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Get a list of table splits
<p/>
@param ns - namespace id
<p/>
@param table_name - table name
<p/>
@return a list of table names
<br/></div><div class="definition"><h4 id="Fn_ClientService_drop_namespace">Function: ClientService.drop_namespace</h4>
<pre><code>void</code> drop_namespace(<code>string</code> ns,
                    <code>bool</code> if_exists = 1)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Drop a namespace
<p/>
@param ns - namespace name
<p/>
@param if_exists - if true, don't barf if the table doesn't exist
<br/></div><div class="definition"><h4 id="Fn_ClientService_rename_table">Function: ClientService.rename_table</h4>
<pre><code>void</code> rename_table(<code><a href="Client.html#Typedef_Namespace">Namespace</a></code> ns,
                  <code>string</code> name,
                  <code>string</code> new_name)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Rename a table
<p/>
@param ns - namespace id
<p/>
@param name - current table name
<p/>
@param new_name - new table name
<br/></div><div class="definition"><h4 id="Fn_ClientService_drop_table">Function: ClientService.drop_table</h4>
<pre><code>void</code> drop_table(<code><a href="Client.html#Typedef_Namespace">Namespace</a></code> ns,
                <code>string</code> name,
                <code>bool</code> if_exists = 1)
    throws <code><a href="Client.html#Struct_ClientException">ClientException</a></code>
</pre>Drop a table
<p/>
@param ns - namespace id
<p/>
@param name - table name
<p/>
@param if_exists - if true, don't barf if the table doesn't exist
<br/></div></body></html>
